class Main {
    static int LED, RTP, UART_TX, UART_RX;
    static int DEBUG0,DEBUG1,DEBUG2,DEBUG3,DEBUG4;

    method void init() {
        let LED = 4096;
        let LED[0] = 0;
        let UART_TX = 4098;
        let UART_RX = 4099;
        let RTP = 4106;
        let DEBUG0 = 4107;
        let DEBUG1 = 4108;
        let DEBUG2 = 4109;
        let DEBUG3 = 4110;
        let DEBUG4 = 4111;
        return;
    }

    function void main() {
        var int rtp;
        do init();

        // command format: header, size, data, [...] // size = bytes after this byte
        // response: header, size, status, command, [data], [...]

        // FIXME: first byte 0x0, subsequent bytes 0xFF - like SDI stuck high?
        // FIXME: sleep is meant to clear pending data so maybe its not I2C IRQ?
        // FIXME: SDO is not meant to be high until response in SPI mode but at least SJ3 is open
        // FIXME: also no error header so its definitely scuffed
        // FIXME: tb is probably wrong / no mention of using SDO idle high in AR1021 docs
        // FIXME: but RTP signals look ok in sim (as expected)
        // FIXME: DEBUG4=RTP_SDI, already flipped by the time Jack code starts
        // FIXME: tried up to 8 times slower (~100kHz) with no change
        // FIXME: RTP.v fully meets all timing constraints / don't think that is the problem
        
        // FIXME: try generating Hack file for 07_OS to run RTP_SCK
        // FIXME: current file looks ok for 0x80 in / 0x55 out
        // FIXME: reg [40:0] spi={1'b0,8'd128,8'd10,8'd25,8'd8,8'd22};

        // send command byte DISABLE_TOUCH
        let rtp = Touch.writeRTP(85); // 0x55
        do UART.writeChar(rtp);

        let rtp = Touch.writeRTP(1);  // 0x01
        do UART.writeChar(rtp);

        let rtp = Touch.writeRTP(16); // 0x10=GET_VERSION, 0x12=ENABLE_TOUCH, 0x13=DISABLE_TOUCH
        do UART.writeChar(rtp);

        // read command response
        let rtp = Touch.writeRTP(0); // 1, 0x55
        do UART.writeChar(rtp);
        if (rtp = 85) {
            do Sys.error(0); // trap on expected byte
        }
        if (~(rtp = 255)) {
            do Sys.error(0); // trap on any new byte
        }

        let rtp = Touch.writeRTP(0); // 2, 0x02
        do UART.writeChar(rtp);
        if (rtp = 2) {
            do Sys.error(0); // trap on expected byte
        }
        
        let rtp = Touch.writeRTP(0); // 3, 0x0
        do UART.writeChar(rtp);
        if (rtp = 0) {
            do Sys.error(0); // trap on expected byte
        }

        let rtp = Touch.writeRTP(0); // 4, 0x10
        do UART.writeChar(rtp);
        if (rtp = 16) { // command type
            do Sys.error(0); // trap on expected byte
        } else {
            let LED[0] = 3;
        }

        return;
    }
}
