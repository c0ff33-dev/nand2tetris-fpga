class Main {
    function void main() {
        var int i, LCD_WAIT;
        let LCD_WAIT = 120; // 500?
        do UART.writeChar(222); // 0xDE (start)
        // FIXME: checked wiring assignment (software/hardware) + codes/timing
        // FIXME: works in arduino via UEXT (display only)
        while (i < 3) {
            // timings are all over the place in docs - wait min 120ms on any major state change
            // SLPIN (enter sleep mode) is default(!) - only responds to SLPOUT
            // DISPOFF (display off) is default(!) - frame buffer disabled & blank page inserted
            // NORON (normal displayy mode on) is default
            // DINVOFF (display inversion off) is default
            // GAMSET (gamma set) gamma curve 1 is default
            // IDMOFF (idle mode off) is default (max colours)
            // some commands will wait for VSCYNC to avoid visual artifacts

            // wake - system starts in SLPIN after power/hw/sw reset
            do Sys.wait(LCD_WAIT); // wait in case coming out of reset
            do ScreenExt.writeCommand(17); // Sleep Out (11h) SLPOUT (wake)
            do Sys.wait(LCD_WAIT); // wait for SLPOUT
            do ScreenExt.writeCommand(41); // Display ON (29h) DISPON
            do Sys.wait(LCD_WAIT); // wait for DISPON

            // frame buffer will be random data on init but sould be noticeable
            do ScreenExt.writeCommand(33); // Display Inversion ON (21h) DINVON
            do Sys.wait(1000);
            do ScreenExt.writeCommand(32); // Display Inversion OFF (20h) DINVOFF
            do Sys.wait(1000);

            // sleep - takes 120ms to go to sleep
            do Sys.wait(LCD_WAIT); // wait in case coming out of reset
            do ScreenExt.writeCommand(40); // Display OFF (28h) DISPOFF
            do Sys.wait(LCD_WAIT); // wait for DISPOFF
            do ScreenExt.writeCommand(16); // Enter Sleep Mode (10h) SLPIN (sleep)
            do Sys.wait(LCD_WAIT); // wait for SLPIN
            let i = i + 1;
        }

        do UART.writeChar(173); // 0xAD (end)
        do Sys.error(0); // done
        return;
    }

    function void rtp_main() {
        var int rtp;
        do UART.writeChar(222); // 0xDE (start)

        // command format: header, size, data, [...] // size = bytes after this byte
        // response: header, size, status, command, [data], [...]

        // FIXME: first byte 0x0, subsequent bytes 0xFF - like SDI stuck high?
        // FIXME: sleep is meant to clear pending data so maybe its not I2C IRQ?
        // FIXME: SDO is not meant to be high until response in SPI mode but at least SJ3 is open
        // FIXME: also no error header so its definitely scuffed
        // FIXME: tb is probably wrong / no mention of using SDO idle high in AR1021 docs
        // FIXME: but RTP signals look ok in 06/07 sims (as expected)
        // FIXME: DEBUG4=RTP_SDI, tested directly in asm driver (rtp_sdi.asm) and its always high
        // FIXME: tried up to 8 times slower (~100kHz) with no change
        // FIXME: RTP.v fully meets all timing constraints

        // send command byte DISABLE_TOUCH
        let rtp = Touch.writeRTP(85); // 0x55
        do UART.writeChar(rtp);

        let rtp = Touch.writeRTP(1);  // 0x01
        do UART.writeChar(rtp);

        let rtp = Touch.writeRTP(16); // 0x10=GET_VERSION, 0x12=ENABLE_TOUCH, 0x13=DISABLE_TOUCH
        do UART.writeChar(rtp);

        // // read command response
        let rtp = Touch.writeRTP(0); // 1, 0x55
        do UART.writeChar(rtp);
        if (rtp = 85) {
            do Sys.error(0); // trap on expected byte
        }
        if (~(rtp = 255)) {
            do Sys.error(0); // trap on any new byte
        }

        let rtp = Touch.writeRTP(0); // 2, 0x02
        do UART.writeChar(rtp);
        if (rtp = 2) {
            do Sys.error(0); // trap on expected byte
        }
        if (~(rtp = 255)) {
            do Sys.error(0); // trap on any new byte
        }
        
        let rtp = Touch.writeRTP(0); // 3, 0x0
        do UART.writeChar(rtp);
        if (rtp = 0) {
            do Sys.error(0); // trap on expected byte
        }
        if (~(rtp = 255)) {
            do Sys.error(0); // trap on any new byte
        }

        let rtp = Touch.writeRTP(0); // 4, 0x10
        do UART.writeChar(rtp);
        if (rtp = 16) { // command type
            do Sys.error(0); // trap on expected byte
        }
        if (~(rtp = 255)) {
            do Sys.error(0); // trap on any new byte
        }

        do GPIO.writeLed(3); // error
        do UART.writeChar(173); // 0xAD (end)

        return;
    }
}
