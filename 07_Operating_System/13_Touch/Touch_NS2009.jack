/** A library to read touch events from the resistive touch panel controller
 * NS2009. */

class Touch{
    static int RTP, x_coord, y_coord, pen, x_max, y_max, adc_max, pressure;
    static int set_x_reg, set_y_reg, set_z_reg, read_cmd;

    function void init() {
        var boolean landscape;
        let RTP = 4106;
        let set_x_reg = 192; // 0xC0 (11000000), in[8]=0 for write
        let set_y_reg = 208; // 0xD0 (11010000), in[8]=0 for write
        let set_z_reg = 224; // 0xE0 (11100000), in[8]=0 for write
        let read_cmd = 256;  // in[8]=1 for read
        let adc_max = 4095;
        let pressure = 25;   // not sure about sensitivity / arbitrary threshold

        let landscape = false;
        if (landscape) {
            let x_max = 320;
            let y_max = 240;
        } else {
            let x_max = 240;
            let y_max = 320;
        }

        return;
    }

    /** writes 8 bits of c to RTP and returns the response of RTP.
     *  (no inter-byte delay needed for NS2009) */
    function int writeRTP(int c) {
        // busy=0x8000(+), else 12 bit ADC data 0x0-0xFFF (0-4095)
        // response is zero for write commands
        let RTP[0] = c; // start RTP_SCL
        while (RTP[0] < 0) {} // wait, don't save yet or it'll read the busy bit
        return RTP[0];
    }

    /** trys to read a valid touch event report. returns true on success.
     *  returns false, if no valid touch event is available. */
    function boolean getEvent() {
        do Touch.getX();
        do Touch.getY();
        do Touch.getPen();
        
        if (pen=1) {
            // do UART.writeChar(Util.logShiftByteRight(pen));
            // do UART.writeChar(pen);
            // do UART.writeChar(Util.logShiftByteRight(x_coord));
            // do UART.writeChar(x_coord);
            // do UART.writeChar(Util.logShiftByteRight(y_coord));
            // do UART.writeChar(y_coord);
            // do UART.writeChar(222); // 0xDE
            // do UART.writeChar(173); // 0xAD

            // ignore malformed data and 0xFFF touch event
            if (x_coord > adc_max | y_coord > adc_max | pen > (4094)) { 
                return false; 
            } else {
                return true;
            }
        }
        return false;
    }

    /** returns the x coordinate in the range [0..4095] of the last touch event report */
    function int getX() {
        var int x;
        do Touch.writeRTP(set_x_reg);
        let x_coord = Touch._map(Touch.writeRTP(read_cmd), 0, adc_max, 0, x_max);
        return x_coord;
    }

    /** returns the x coordinate in the range [0..4095] of the last touch event report */
    function int getY() {
        var int y;
        do Touch.writeRTP(set_y_reg);
        let y = Touch._map(Touch.writeRTP(read_cmd), 0, adc_max, 0, y_max);
        let y_coord = y_max - y; // NS2009 inverts the Y axis by default
        return y_coord;
    }

    /** returns the pen value (1 = down, 0 = up) of the last touch event report */
    function boolean getPen() {
        var int p;
        do Touch.writeRTP(set_z_reg);
        let p = Touch.writeRTP(read_cmd);
        if (p > pressure) {
            let pen = 1;
        } else {
            let pen = 0;
        }
        return pen;
    }

    /** Map 12 bit ADC coords to screen resolution */
    function int _map(int data, int in_min, int in_max, int out_min, int out_max) {
        // this is basically just integer division
        var int i, pos, out_range, in_range, scaled, accum;

        // TODO: not sure about clamping vs throwing an error here
        if (data < in_min) { let data = in_min; }
        if (data > in_max) { let data = in_max; }

        let pos = data - in_min;
        let out_range = out_max - out_min;
        let in_range = in_max - in_min;

        let scaled = 0;
        let accum = 0;
        let i = 0;
        
        while (i < pos) {
            let i = i + 1;
            let accum = accum + out_range;
            if ((accum > in_range)|(accum = in_range)) {
                let accum = accum - in_range;
                let scaled = scaled + 1;
            }
        }

        return out_min + scaled;
    }
}