/** A library to read touch events from the resistive touch panel controller
 * NS2009. */

class Touch{
    static int RTP, x_coord, y_coord, pen;
    static int set_x_reg, set_y_reg, set_z_reg, read_cmd;

    function void init() {
        let RTP = 4106;
        let set_x_reg = 192; // 0xC0 (11000000), in[8]=0 for write
        let set_y_reg = 208; // 0xD0 (11010000), in[8]=0 for write
        let set_z_reg = 224; // 0xE0 (11100000), in[8]=0 for write
        let read_cmd = 256;  // in[8]=1 for read
        return;
    }

    /** writes 8 bits of c to RTP and returns the response of RTP.
     *  (no inter-byte delay needed for NS2009) */
    function int writeRTP(int c) {
        // busy=0x8000(+), else 12 bit ADC data 0x0-0xFFF (0-4095)
        // response is zero for write commands
        var int rx;
        let RTP[0] = c; // start RTP_SCL
        while (RTP[0] < 0) {
            let rx = RTP[0]; // read RTP
        }
        return rx;
    }

    /** trys to read a valid touch event report. returns true on success.
     *  returns false, if no valid touch event is available. */
    function boolean getEvent() {
        return true;
    }

    /** returns the x coordinate in the range [0..4095] of the last touch event report */
    function int getX() {
        var int _;
        let _ = Touch.writeRTP(set_x_reg);
        do Sys.wait(1); // 1ms
        let x_coord = Touch.writeRTP(read_cmd);
        // TODO: mapping (same range apparently)
        return x_coord;
    }

    /** returns the x coordinate in the range [0..4095] of the last touch event report */
    function int getY() {
        var int _;
        let _ = Touch.writeRTP(set_y_reg);
        do Sys.wait(1); // 1ms
        let y_coord = Touch.writeRTP(read_cmd);
        // TODO: mapping (same range apparently)
        return y_coord;
    }

    /** returns the pen value (1 = down, 0 = up) of the last touch event report */
    function boolean getPen() {
        var int _;
        let _ = Touch.writeRTP(set_z_reg);
        do Sys.wait(1); // 1ms
        let pen = Touch.writeRTP(read_cmd);
        // TODO: mapping (same range apparently)
        return pen;
    }
}

// void NS2009::Scan ()
// {
//   CheckTouched ();
//   RawX = ReadRegister(NS2009_READ_X);
//   X = Map_Data (RawX, MinX, MaxX, 0, SCREEN_SIZE_X);
//   RawY = ReadRegister(NS2009_READ_Y);
//   Y = Map_Data (RawY, MinY, MaxY, 0, SCREEN_SIZE_Y);
// 
//   // FlipX=false, FlipY=true
//   if (FlipX)
//     X = SCREEN_SIZE_X - X;
//   if (FlipY)
//     Y = SCREEN_SIZE_Y - Y;
// }

// bool NS2009::CheckTouched ()
// {
//   do
//   {
//     RawZ = ReadRegister(NS2009_READ_Z);
//   }
//   while (RawZ == 0xFFF);  // sometimes the I2C reading gives a false positive by returning only ones ==> 0xFFF = 4095
//   Touched = (RawZ > THRESHOLD_Z);
//   return Touched;
// }

// uint16_t Map_Data (uint16_t Data, uint16_t InMin, uint16_t InMax, uint16_t OutMin, uint16_t OutMax)
// {
//   if (Data < InMin)
//     Data = InMin;
//   if (Data > InMax)
//     Data = InMax;
//   return (uint16_t)(((uint32_t)(Data - InMin) * (OutMax - OutMin)) / (InMax - InMin)+ OutMin);
// }