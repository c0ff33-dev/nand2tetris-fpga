/**
* A library of functions for displaying graphics on the screen.
* The connected LCD physical screen consists of 320 rows (indexed 0..319, top to bottom)
* of 240 pixels each (indexed 0..239, left to right). The top left pixel on 
* the screen is indexed (0,0). Every pixel can be set to a 16 bit colour code composed of
* RGB parts of 5 bit red, 6 bit green and 5 bit blue: rrrrrggggggbbbbb.
*
* CSX is implicitly driven low on all SPI transactions by the FPGA controller and only needs
* to be driven high when the current batch of transactions is finished.
*/
class ScreenExt {
    static int LCD, LCD_WAIT, fgcolour, bgcolour, pixels; // TODO: do fg/bg need to be saved?
    // timings are all over the place in docs - wait min 120ms on any major state change
    // SLPIN (enter sleep mode) is default(!) - only responds to SLPOUT
    // DISPOFF (display off) is default(!) - frame buffer disabled & blank page inserted
    // NORON (normal displayy mode on) is default
    // DINVOFF (display inversion off) is default
    // GAMSET (gamma set) gamma curve 1 is default
    // IDMOFF (idle mode off) is default (max colours)
    // some commands will wait for VSCYNC to avoid visual artifacts

    /** Initializes the Screen. */
    function void init() {
        let LCD = 4104; // LCD[0]=LCD8, LCD[1]=LCD16
        let LCD_WAIT = 120; // transition in milliseconds constant
        
        // ILI9341V initialization: config

        // MADCTL 0x36
        // Note: the addressing of how data is written to memory in the FPGA is
        // not affeced by MADCTL D5-7, the change is executed by manipulating
        // the read pointer of the frame memory on the ILI9341V side -
        // basically the image can appear flipped/mirrored compared to the source
        // - Row top to bottom (MADCTL D7/MY=0)
        // - Column left to right (MADCTL D6/MX=0) // adafruit=1, image is flipped on x-axis
        // - Row/column exchange: normal (MADCTL D5/MV=0)
        // - V-draw: top to bottom (MADCTL D4/ML=0)
        // - RGB-BGR: RGB (MADCTL D3/BGR=0) // adafruit=1, BGR order (wrong for this implementation?)
        // - H-draw: left to right (MADCTL D2/MH=0)
        // RAMWR: ignore excess data calls (IFCTL D0/WEMODE=0) or redraw (default=1)

        // FIXME: RGB seems wrong, possibly still need image flip but hard to tell atm
        // FIXME: current setWindow clamps to top right
        do ScreenExt.writeCommand(54); // MADCTL 0x36
        // do ScreenExt.writeData(72); // Param 0x48 MX=1, BGR=1 (same as adafruit)
        // do ScreenExt.writeData(64); // Param 0x40 MX=1 only      
        do ScreenExt.writeData(0); // Param 0x0 (default)

        // TODO: this works/is definitely required
        do ScreenExt.writeCommand(58); // COLMOD 0x3A
        do ScreenExt.writeData(85); // Param 0x55 (16 bit RGB format)

        // TODO: function?
        // do ScreenExt.writeCommand(32); // DINVOFF 0x20 (regular display)
        // do Sys.wait(LCD_WAIT);
        // do ScreenExt.writeCommand(33); // DINVON 0x21 (invert display)
        // do Sys.wait(LCD_WAIT);
        
        // ILI9341V initialization: awaken
        // these are the only essential SPI commands
        // without any other initialization this will be random pixels but have to fully power on/off
        // to reset frame buffer as RESET is not connected to UEXT on MOD-LCD2.8RTP
        // the uninitialized display it will have the appearance of grey-ish vertical scanlines
        do Sys.wait(LCD_WAIT); // wait in case coming out of reset
        do ScreenExt.writeCommand(17); // SLPOUT 0x11 (wake)
        do Sys.wait(LCD_WAIT); // wait for SLPOUT
        do ScreenExt.writeCommand(41); // DISPON 0x29 (enable display)
        do Sys.wait(LCD_WAIT); // wait for DISPON
        
        do ScreenExt._completeTransaction();
        return;
    }

    /** writes the 8 bit command with DCX wire set to low */
    function void writeCommand(int cmd) {
        var int busy; // 0x0=ready, 0x8000=busy
        let LCD[0] = cmd; // send command byte
        let busy = -1;
        while (~(busy = 0)) {
            let busy = LCD[0]; // read response
        }
        return;
    }

    /** writes 16 bit data to LCD with DCX wire set to high. */
    function void writeData(int data) {
        var int busy; // 0x0=ready, 0x8000=busy
        let LCD[1] = data; // send data byte(s)
        let busy = -1;
        while (~(busy = 0)) {
            let busy = LCD[1]; // read response
        }
        return;
    }

    /** Sets the current pen colour, to be used for all subsequent drawXXX
     *  commands. colours are represented by 16 bit RGB values with
     *  binary representation: rrrrrggggggbbbbb */
    function void setPencolour(int colour) {
        // FIXME: non-black/white colours seem wrong and have scanlines
        let fgcolour = colour;
        return;
    }

    function int getPencolour() {
        return fgcolour;
    }

    /** Sets the current background colour, to be used for clearScreen()
     *  and drawBitMap() commands.
     *  colours are represented by 16 bit RGB values: rrrrrggggggbbbbb */
    function void setBackcolour(int colour) {
        let bgcolour = colour;
        return;
    }

    function int getBackcolour() {
        return bgcolour;
    }
   
    /** sets the Window to a rectangle with upper left corner (x1,y1)
     * and lower right corner (x2,y2). The next w*h calls to
     * writeRgbData(int colour) will paint the w*h pixels in the rectangle
     * in the corresponding colour.*/ 
    function void setWindow(int x1, int y1, int x2, int y2) {
        // valid ranges: x2 >= x1, 0-239, y2 >= y1, 0-319
        // otherwise ignored by ILI9341V
        // when MADCTL D5(MV)=0 (default) CASET=X, PASET=Y
        // CASET SC/EC=left/right column extent
        // PASET SP/EP=top/bottom row extent
        // high byte: (x/y shr 8 AND 0xFF) to shift right & mask the high byte
        // low byte: (x/y AND 0xFF) to mask high byte leaving the low byte

        // FIXME: all tests pass
        // var int d;
        // let d = ScreenExt._maskHiByte(240); // pass
        // if (~(d = 240)) {
        //     do Sys.error(0);
        // }

        // let d = ScreenExt._maskHiByte(320); // pass
        // if (~(d = 64)) {
        //     do Sys.error(0);
        // }

        // let d = Util.logShiftByteRight(240); // pass
        // if (~(d = 0)) {
        //     do Sys.error(0);
        // }

        // let d = Util.logShiftByteRight(320); // pass
        // if (~(d = 1)) {
        //     do Sys.error(0);
        // }

        // let d = ScreenExt._maskHiByte(Util.logShiftByteRight(240)); // pass
        // if (~(d = 0)) {
        //     do Sys.error(0);
        // }

        // let d = ScreenExt._maskHiByte(Util.logShiftByteRight(320)); // pass
        // if (~(d = 1)) {
        //     do Sys.error(0);
        // }

        // FIXME: enable
        // for 16 bit values rsh 8 is sufficient to mask
        // adafruit doesn't bother masking lo byte either
        // do ScreenExt.writeCommand(42); // CASET 0x2A (column adrr set)
        // do ScreenExt.writeData(Util.logShiftByteRight(x1)); // SC[15:8]
        // do ScreenExt.writeData(x1); // SC[7:0]
        // do ScreenExt.writeData(Util.logShiftByteRight(x2)); // EC[15:8]
        // do ScreenExt.writeData(x2); // EC[7:0]

        // do ScreenExt.writeCommand(43); // PASET 0x2B (page [row] adrr set)
        // do ScreenExt.writeData(Util.logShiftByteRight(y1)); // SP[15:8]
        // do ScreenExt.writeData(y1); // SP[7:0]
        // do ScreenExt.writeData(Util.logShiftByteRight(y2)); // EP[15:8]
        // do ScreenExt.writeData(y2); // EP[7:0]

        // FIXME: bounding box issue - why does this look like its clamping in reverse? (1 pixel)
        do ScreenExt.writeCommand(42); // CASET 0x2A (column adrr set)
        do ScreenExt.writeData(0); // SC[15:8]
        do ScreenExt.writeData(0); // SC[7:0]
        do ScreenExt.writeData(0); // EC[15:8] - max (239)
        do ScreenExt.writeData(239); // EC[7:0]
        do ScreenExt.writeCommand(43); // PASET 0x2B (page [row] adrr set)
        do ScreenExt.writeData(0); // SP[15:8]
        do ScreenExt.writeData(0); // SP[7:0]
        do ScreenExt.writeData(1); // EP[15:8] - max (319)
        do ScreenExt.writeData(63); // EP[7:0]
        do ScreenExt._completeTransaction();

        // store the sum of pixels to paint rather than coords
        // warning: need to stay within 15 bit ALU limits
        // let pixels = Math.multiply((x2-x1+1),(y2-y1+1)); FIXME: enable
        return;
    }

    /** sets the 16 bit rgb colour for the next pixel in the rectangle 
     * set by setWindow(int x1, int y1, int x2, int y2).*/
    function void writeRgbData(int colour) {
        return;
    }

    // drive CSX high/DCX low without sending a byte
    // it is fine to leave CSX low for multiple SPI transactions
    function void _completeTransaction() {
        var int busy; // 0x0=ready, 0x8000=busy
        let LCD[0] = 256; // send command byte
        let busy = -1;
        while (~(busy = 0)) {
            let busy = LCD[0]; // read response
        }
        return;
    }

    function void fillScreen() {
        var int i, j;
        
        // TODO: adafruit defines x2/y2 as x+w-1 and y+h-1 which is intuitive
        do ScreenExt.setWindow(0,0,239,319);
        do ScreenExt.writeCommand(44); // RAMWR 0x2C (write to VRAM)
       
        // call writeData() w*h times
        // TODO: something like this will work when pixels is <= 32767
        // while (pixels > 0) {
        //     do ScreenExt.writeData(ScreenExt.getPencolour());
        //     let pixels = pixels - 1;
        // }

        // TODO: otherwise when pixels > 32767:
        let i = 240;
        while (i > 0) {
            let j = 320;
            while (j > 0) {
                do ScreenExt.writeData(ScreenExt.getPencolour());
                let j = j - 1;
            }
            let i = i - 1;
        }
        let pixels = 0;

        do ScreenExt._completeTransaction();
        return;
    }

    /** draws the BitMap into the rectangle with upper left corner (x1,y1)
     *  and lower right corner (x2,y2) using the pen colour for all 1s and the
     *  back colour for all 0s in the BitMap. BitMap is an Array of h integers
     *  representing up to 16 pixel in the row. The rectangle is limited
     *  to maximal 16 pixels in width.*/ 
    function void drawBitMap(int x1, int y1, int x2, int y2, Array map) {
        return;
    }

    /** RGB values for various colours. */
    function int BLACK() {
        return 0; // 00000 000000 00000
    }
    function int NAVY() {
        return 30; // 00000 000000 11110
    }
    function int BLUE() {
        return 31; // 00000 000000 11111
    }
    function int LIME() {
        return 2016; // 00000 111111 00000
    }
    function int GREEN() {
        return 1920; // 00000 111100 00000
    }
    function int CYAN() {
        return 2047; // 00000 111111 11111
    }
    function int MAROON() {
        return -4096; // 11110 000000 00000
    }
    function int PURPLE() {
        return -4066; // 11110 000000 11110
    }
    function int OLIVE() {
        return -2176; // 11110 111100 00000
    }
    function int DARKGREY() {
        return -14824; // 11000 110000 11000
    }
    function int TEAL() {
        return 1950; // 00000 111000 11100
    }
    function int LIGHTGREY() {
        return -6372; // 11100 111000 11100
    }
    function int RED() {
        return -2048; // 11111 000000 00000
    }
    function int MAGENTA() {
        return -2017; // 11111 000000 11111
    }
    function int YELLOW() {
        return -32; // 11111 111111 00000
    }
    function int ORANGE() {
        return -128; // 11111 111000 00000
    }
    function int WHITE() {
        return -1; // 11111 111111 11111
    }

    // TODO: adafruit functions

    // void Adafruit_ILI9341::setRotation(uint8_t m) {
    //     rotation = m % 4; // can't be higher than 3
    //     switch (rotation) {
    //         case 0:
    //             m = (MADCTL_MX | MADCTL_BGR);
    //             _width  = ILI9341_TFTWIDTH;
    //             _height = ILI9341_TFTHEIGHT;
    //             break;
    //         case 1:
    //             m = (MADCTL_MV | MADCTL_BGR);
    //             _width  = ILI9341_TFTHEIGHT;
    //             _height = ILI9341_TFTWIDTH;
    //             break;
    //         case 2:
    //             m = (MADCTL_MY | MADCTL_BGR);
    //             _width  = ILI9341_TFTWIDTH;
    //             _height = ILI9341_TFTHEIGHT;
    //             break;
    //         case 3:
    //             m = (MADCTL_MX | MADCTL_MY | MADCTL_MV | MADCTL_BGR);
    //             _width  = ILI9341_TFTHEIGHT;
    //             _height = ILI9341_TFTWIDTH;
    //             break;
    //     }
    // 
    //     startWrite();
    //     writeCommand(ILI9341_MADCTL);
    //     spiWrite(m);
    //     endWrite();
    // }

    // void Adafruit_ILI9341::invertDisplay(boolean i) {
    //     startWrite();
    //     writeCommand(i ? ILI9341_INVON : ILI9341_INVOFF);
    //     endWrite();
    // }
}
